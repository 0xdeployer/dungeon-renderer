import { Neighbors } from './Neighbors';
import { Cell } from './Cell';

export class Dungeon {
  cells: Cell[][];
  height: number;
  width: number;
  constructor(cells: Cell[][]) {
    this.cells = cells;
    this.width = cells[0].length;
    this.height = cells.length;
  }

  print() {
    console.log(this.toString());
  }

  toString() {
    return this.cells
      .map(row => row.map(s => s.base.type[0]).join(' '))
      .join('\n');
  }

  // get a cell by x/y coordinates
  cell(x: number, y: number): Cell | null {
    const row = this.cells[y];
    if (row === undefined) return null;
    return row[x] ?? null;
  }

  // get neighbors of a cell as util class
  neighbors(x: number, y: number): Neighbors {
    return new Neighbors(this, x, y);
  }

  // return a new dungeon with a function mapping over each cell
  map(
    fn: (cell: Cell, neighbors: Neighbors, x: number, y: number) => Cell,
  ): Dungeon {
    const cells = [];
    this.forEach((cell, neighbors, x, y) => {
      cells[y] ||= [];
      cells[y][x] = fn(cell, neighbors, x, y);
    });
    return new Dungeon(cells);
  }

  // run a side effectful function for each cell of the dungeon
  forEach(
    fn: (cell: Cell, neighbors: Neighbors, x: number, y: number) => unknown,
  ): void {
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        fn(this.cells[y][x], this.neighbors(x, y), x, y);
      }
    }
  }

  // return a new dungeon generated by repeated applying processor functions
  process(...fns: ((d: Dungeon) => Dungeon)[]): Dungeon {
    return fns.reduce((memo, fn) => fn(memo), this);
  }
}
